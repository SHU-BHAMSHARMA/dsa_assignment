### <p align="center"> INTRODUCTION </p>

This program implements a Doubly Linked List (DLL). Unlike a singly linked list, each node in a DLL contains two pointers, allowing for efficient traversal and manipulation in both forward and backward directions. This program specifically demonstrates insertion after a known value and deletion of a specific node.

---

### <p align="center"> DATA STRUCTURE USED </p>

The data structure is a struct dNode which contains three members:

data: An integer value.

next: A pointer to the following node in the list.

prev: A pointer to the preceding node, enabling bidirectional navigation.

---

### <p align="center"> FUNCTIONS USED </p>

insertAfterValue(struct dNode *head, int target, int newValue)
Searches for a node containing the target value. Once found, it dynamically allocates a new node and rearranges four pointers (the new node's prev/next and the neighbors' links) to place the new node correctly in the sequence.

deleteByValue(struct dNode **head_ref, int target)
Locates the node containing the target value. It safely unlinks the node by connecting its predecessor directly to its successor, handles the special case of deleting the head node, and then frees the memory.

printList(struct dNode *node)
Iterates through the list using the next pointers and prints the data in each node to the console to visualize the current state of the list.

---

### <p align="center"> WORKING ALGORITHM </p>

Insertion Logic:

Locate the target node.

Set the new node's next to the target's next.

Set the new node's prev to the target.

Update the target's next and the successor's prev to point to the new node.

Deletion Logic:

Locate the target node.

Connect temp->prev->next to temp->next.

Connect temp->next->prev to temp->prev.

Free the memory of the isolated node.

---

### <p align="center"> SAMPLE OUTPUT </p>

Initial State: 100

After Inserting 200 and 300:
Current List: 100 <-> 200 <-> 300 <-> NULL

After Deleting 200:
Current List: 100 <-> 300 <-> NULL